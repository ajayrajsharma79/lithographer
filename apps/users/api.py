from rest_framework import serializers
from django.contrib.auth import get_user_model
from .models import Role, APIKey # Removed Permission import

CMSUser = get_user_model()

# Removed PermissionSerializer as Permission model was removed

class RoleSerializer(serializers.ModelSerializer):
    """Serializer for the Role model."""
    # Permissions are now stored as a list of strings in a JSONField
    # No need for PrimaryKeyRelatedField or nested serializer here.
    # The 'permissions' field from the model will be handled directly.

    class Meta:
        model = Role
        fields = ['id', 'name', 'description', 'is_system_role', 'permissions'] # Use the JSONField directly
        read_only_fields = ['id', 'is_system_role'] # System roles are managed internally

class CMSUserSerializer(serializers.ModelSerializer):
    """Serializer for the CMSUser model."""
    # Use RoleSerializer for detailed role info on read, PrimaryKeyRelatedField for write
    roles = serializers.PrimaryKeyRelatedField(
        queryset=Role.objects.all(),
        many=True,
        required=False # Allow creating users without roles initially
    )
    roles_detail = RoleSerializer(source='roles', many=True, read_only=True)
    full_name = serializers.CharField(source='get_full_name', read_only=True)

    class Meta:
        model = CMSUser
        fields = [
            'id', 'email', 'first_name', 'last_name', 'full_name',
            'is_active', 'is_staff', 'is_superuser', # Include auth fields
            'date_joined', 'last_login', # Include relevant dates
            'roles', 'roles_detail',
            'password' # Include password field for creation/update (write-only)
        ]
        read_only_fields = ['id', 'is_staff', 'is_superuser', 'date_joined', 'last_login', 'full_name']
        extra_kwargs = {
            'password': {'write_only': True, 'style': {'input_type': 'password'}, 'required': False},
            'email': {'required': True},
            'first_name': {'required': True},
            'last_name': {'required': True},
        }

    def create(self, validated_data):
        # Handle password hashing and role assignment
        roles_data = validated_data.pop('roles', [])
        # Use the custom manager's create_user method
        user = CMSUser.objects.create_user(**validated_data)
        user.roles.set(roles_data)
        return user

    def update(self, instance, validated_data):
        # Handle password update and role assignment
        password = validated_data.pop('password', None)
        roles_data = validated_data.pop('roles', None) # Use None to detect if roles were passed

        # Update other fields
        instance = super().update(instance, validated_data)

        # Set password if provided
        if password:
            instance.set_password(password)
            instance.save(update_fields=['password'])

        # Set roles if provided (otherwise leave them unchanged)
        if roles_data is not None:
            instance.roles.set(roles_data)

        return instance


class APIKeySerializer(serializers.ModelSerializer):
    """Serializer for the APIKey model."""
    # Represent user by email on read, allow setting via PK on write
    user_email = serializers.EmailField(source='user.email', read_only=True)
    user = serializers.PrimaryKeyRelatedField(
        queryset=CMSUser.objects.all(),
        write_only=True,
        required=True
    )
    key = serializers.CharField(read_only=True) # Key is generated by the model

    class Meta:
        model = APIKey
        fields = [
            'id', 'name', 'user', 'user_email', 'key',
            'created_at', 'last_used_at', 'is_active'
            # 'expires_at' # Add if expiration is implemented
        ]
        read_only_fields = ['id', 'key', 'created_at', 'last_used_at']
        extra_kwargs = {
            'user': {'write_only': True},
        }